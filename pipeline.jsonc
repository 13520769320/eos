{
    "eosio-code-coverage":
    {
        "exclude": [ // ignore coverage reports from source filenames matching these PCREs
            "^/build/",
            "^/coverage/",
            "^/.git/",
            "^/libraries/eos-vm/",
            "^/libraries/wasm-jit/",
            "^/node_modules/",
            "^/unittests/"
        ],
        "expect": [ // expect coverage reports from source filenames matching these PCREs
            "[.]c(pp)?([.]in)?$",
            "[.]h(pp)?([.]in)?$"
        ]
    },
    "eosio-docker-builds":
    {
        "environment":
        {
            "BUILDER_TAG": "v2.0.0"
        }
    },
    "eos-multiversion-tests":
    {
        "environment":
        {
            "IMAGE_TAG": "_1-8-0-rc2"
        },
        "configuration":
        [
            "170=v1.7.0"
        ]
    },
    // This test takes a disk image containing state files generated by a
    // previous version of nodeos specified via a commit hash using the
    // parameter `eosio-resume-from-state.test.commit` below and attempts
    // to start the current version of nodeos under test from those state
    // files. A passing test means nodeos initialized at the same LIB the
    // previous version left off on.
    //
    // You would want to update the state files any time you intentionally make
    // a change which breaks compatibility with the existing state files. In
    // that case, you'd kick off an eosio-snapshot build to collect a disk
    // image with state files from the new version of nodeos, then update the
    // git reference for the eosio-resume-from-state pipeline here. This
    // reference can be a branch, commit, or tag, and you can also have more
    // than one.
    "eosio-resume-from-state":
    {
        "test":
        [
            {
                "commit": "febadedb6683857a76815846443727e5d280624e"
            }
        ]
    }
}
